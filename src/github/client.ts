import { Octokit } from '@octokit/rest';
import type { SynthesisResult } from '../head/synthesizer.js';
import type { DebateResult } from '../debate/types.js';

export interface GitHubConfig {
  token: string;
  owner: string;
  repo: string;
  prNumber: number;
}

export interface CommentOptions {
  synthesis: SynthesisResult;
  debateResults?: DebateResult[];
  metadata: {
    totalReviewers: number;
    successfulReviewers: number;
    duration: number;
  };
}

export class GitHubClient {
  private octokit: Octokit;
  private config: Omit<GitHubConfig, 'token'> & { token: string };

  constructor(config: GitHubConfig) {
    // Validate token
    if (!config.token || config.token.trim().length === 0) {
      throw new Error('GitHub token is required. Set GITHUB_TOKEN environment variable.');
    }

    // Store config with redacted token to prevent accidental exposure
    this.config = { ...config, token: '[REDACTED]' };

    // Use actual token for Octokit
    this.octokit = new Octokit({
      auth: config.token,
    });
  }

  /**
   * Extract diff from a GitHub Pull Request
   */
  async getPullRequestDiff(): Promise<string> {
    const { data } = await this.octokit.pulls.get({
      owner: this.config.owner,
      repo: this.config.repo,
      pull_number: this.config.prNumber,
      mediaType: {
        format: 'diff',
      },
    });

    // @ts-expect-error - data is string when format is 'diff'
    return data as string;
  }

  /**
   * Post review summary as a comment
   */
  async postReviewSummary(options: CommentOptions): Promise<void> {
    const body = this.formatSummaryComment(options);

    await this.octokit.issues.createComment({
      owner: this.config.owner,
      repo: this.config.repo,
      issue_number: this.config.prNumber,
      body,
    });
  }

  /**
   * Post inline comments on specific lines
   */
  async postInlineComments(options: CommentOptions): Promise<void> {
    const comments = this.formatInlineComments(options);

    // Get PR details to get the commit SHA
    const { data: pr } = await this.octokit.pulls.get({
      owner: this.config.owner,
      repo: this.config.repo,
      pull_number: this.config.prNumber,
    });

    const commitSha = pr.head.sha;

    // Post review with comments
    await this.octokit.pulls.createReview({
      owner: this.config.owner,
      repo: this.config.repo,
      pull_number: this.config.prNumber,
      commit_id: commitSha,
      event: 'COMMENT',
      comments: comments.map((c) => ({
        path: c.path,
        line: c.line,
        side: 'RIGHT',
        body: c.body,
      })),
    });
  }

  private formatSummaryComment(options: CommentOptions): string {
    const { synthesis, debateResults, metadata } = options;

    const severitySummary = `
- ðŸ”´ Critical: ${synthesis.bySeverity.CRITICAL}
- ðŸŸ  Major: ${synthesis.bySeverity.MAJOR}
- ðŸŸ¡ Minor: ${synthesis.bySeverity.MINOR}
- ðŸ’¡ Suggestions: ${synthesis.bySeverity.SUGGESTION}
`.trim();

    const debateSection = debateResults?.length
      ? `
## ðŸ—£ï¸ Debates Conducted

${debateResults.map((d) => `- **${d.issue.file}:${d.issue.line}** (${d.issue.category}) - ${d.consensus} consensus after ${d.rounds} round(s)`).join('\n')}
`
      : '';

    const reviewerDetails = synthesis.issues
      .slice(0, 10) // Top 10 issues
      .map((issue) => {
        const reviewerList = issue.reviewers
          .map((r) => `\`${r}\``)
          .join(', ');

        return `
<details>
<summary>${this.getSeverityEmoji(issue.severity)} <strong>${issue.title}</strong> (Line ${issue.line})</summary>

**Severity:** ${issue.severity}
**Category:** ${issue.category}
**Reviewers:** ${reviewerList}

${issue.description}

${issue.suggestion ? `**Suggestion:** ${issue.suggestion}` : ''}

**Confidence:** ${(issue.confidence * 100).toFixed(0)}%

</details>
`;
      })
      .join('\n');

    return `## ðŸ¤– Oh My CodeReview - Automated Review

### Summary
${severitySummary}

**Total Issues:** ${synthesis.totalIssues}
**Reviewers:** ${metadata.successfulReviewers}/${metadata.totalReviewers}
**Duration:** ${(metadata.duration / 1000).toFixed(1)}s

${debateSection}

### Top Issues
${reviewerDetails}

---
<sub>Generated by [Oh My CodeReview](https://github.com/your-org/oh-my-codereview) with ${metadata.successfulReviewers} AI reviewers</sub>
`;
  }

  private formatInlineComments(options: CommentOptions): Array<{
    path: string;
    line: number;
    body: string;
  }> {
    const { synthesis } = options;
    const comments: Array<{ path: string; line: number; body: string }> = [];

    // Group issues by file and line
    const issuesByLocation = new Map<string, typeof synthesis.issues>();

    for (const issue of synthesis.issues) {
      const key = `${issue.file}:${issue.line}`;
      if (!issuesByLocation.has(key)) {
        issuesByLocation.set(key, []);
      }
      issuesByLocation.get(key)!.push(issue);
    }

    // Create one comment per location with all issues
    for (const [location, issues] of issuesByLocation.entries()) {
      const [file, lineStr] = location.split(':');
      const line = parseInt(lineStr);

      const body = this.formatIssueGroup(issues);

      comments.push({
        path: file,
        line: line,
        body,
      });
    }

    return comments;
  }

  private formatIssueGroup(issues: SynthesisResult['issues']): string {
    if (issues.length === 1) {
      const issue = issues[0];
      return `${this.getSeverityEmoji(issue.severity)} **${issue.title}**

${issue.description}

${issue.suggestion ? `**Suggestion:** ${issue.suggestion}` : ''}

**Reviewers:** ${issue.reviewers.map((r) => `\`${r}\``).join(', ')}
**Confidence:** ${(issue.confidence * 100).toFixed(0)}%
`;
    }

    // Multiple issues at same location
    return `### Multiple Issues Detected

${issues
  .map(
    (issue) => `
<details>
<summary>${this.getSeverityEmoji(issue.severity)} ${issue.title}</summary>

${issue.description}

${issue.suggestion ? `**Suggestion:** ${issue.suggestion}` : ''}

**Reviewers:** ${issue.reviewers.map((r) => `\`${r}\``).join(', ')}
**Confidence:** ${(issue.confidence * 100).toFixed(0)}%

</details>
`
  )
  .join('\n')}
`;
  }

  private getSeverityEmoji(severity: string): string {
    switch (severity) {
      case 'CRITICAL':
        return 'ðŸ”´';
      case 'MAJOR':
        return 'ðŸŸ ';
      case 'MINOR':
        return 'ðŸŸ¡';
      case 'SUGGESTION':
        return 'ðŸ’¡';
      default:
        return 'âšª';
    }
  }
}

/**
 * Parse GitHub repository information from various formats
 */
export function parseGitHubRepo(input: string): {
  owner: string;
  repo: string;
  prNumber?: number;
} {
  // URL format: https://github.com/owner/repo/pull/123
  const urlMatch = input.match(/github\.com\/([^/]+)\/([^/]+)\/pull\/(\d+)/);
  if (urlMatch) {
    return {
      owner: urlMatch[1],
      repo: urlMatch[2],
      prNumber: parseInt(urlMatch[3]),
    };
  }

  // Short format: owner/repo#123
  const shortMatch = input.match(/^([^/]+)\/([^#]+)#(\d+)$/);
  if (shortMatch) {
    return {
      owner: shortMatch[1],
      repo: shortMatch[2],
      prNumber: parseInt(shortMatch[3]),
    };
  }

  // Repo only: owner/repo
  const repoMatch = input.match(/^([^/]+)\/(.+)$/);
  if (repoMatch) {
    return {
      owner: repoMatch[1],
      repo: repoMatch[2],
    };
  }

  throw new Error(`Invalid GitHub repository format: ${input}`);
}
