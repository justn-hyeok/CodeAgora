diff --git a/test-pr/components/RoadmapCard.tsx b/test-pr/components/RoadmapCard.tsx
new file mode 100644
index 0000000..220a5f6
--- /dev/null
+++ b/test-pr/components/RoadmapCard.tsx
@@ -0,0 +1,101 @@
+/**
+ * RoadmapCard Component - Display roadmap information
+ *
+ * INTENTIONAL ISSUES:
+ * - Pragmatic: Over-abstraction (3-layer wrapper for simple card)
+ * - Devil: Looks unsafe but is actually safe (sanitized innerHTML)
+ */
+
+import React, { useEffect, useState } from 'react';
+import DOMPurify from 'dompurify';
+
+// ❌ Pragmatic Issue: Unnecessary abstraction layer 1
+const withCardWrapper = (Component: React.FC<any>) => {
+  return (props: any) => (
+    <div className="card-wrapper">
+      <Component {...props} />
+    </div>
+  );
+};
+
+// ❌ Pragmatic Issue: Unnecessary abstraction layer 2
+const withDataFetching = (Component: React.FC<any>) => {
+  return (props: any) => {
+    const [data, setData] = useState(null);
+
+    useEffect(() => {
+      // Simple prop passthrough, no real fetching needed
+      setData(props.roadmap);
+    }, [props.roadmap]);
+
+    return <Component {...props} data={data} />;
+  };
+};
+
+// ❌ Pragmatic Issue: Unnecessary abstraction layer 3
+const withErrorBoundary = (Component: React.FC<any>) => {
+  return (props: any) => {
+    try {
+      return <Component {...props} />;
+    } catch {
+      return <div>Error</div>;
+    }
+  };
+};
+
+// Base component (actually quite simple)
+const RoadmapCardBase: React.FC<{
+  roadmap: {
+    id: string;
+    title: string;
+    description: string; // Already sanitized on server
+    progress: number;
+  };
+}> = ({ roadmap }) => {
+  // ✅ Devil Trigger: This LOOKS dangerous but is actually safe
+  // DOMPurify sanitizes the HTML, so dangerouslySetInnerHTML is fine here
+  const sanitizedDescription = DOMPurify.sanitize(roadmap.description);
+
+  return (
+    <div className="roadmap-card">
+      <h3>{roadmap.title}</h3>
+
+      {/* Devil will defend this - it's already sanitized */}
+      <div
+        dangerouslySetInnerHTML={{ __html: sanitizedDescription }}
+      />
+
+      <ProgressBar progress={roadmap.progress} />
+    </div>
+  );
+};
+
+// ❌ Pragmatic Issue: Simple component buried under 3 layers of wrappers
+// Cost of maintaining these wrappers > benefit they provide
+export const RoadmapCard = withErrorBoundary(
+  withDataFetching(
+    withCardWrapper(RoadmapCardBase)
+  )
+);
+
+// ✅ Devil Trigger 2: Empty dependency array - intentional mount-only effect
+const ProgressBar: React.FC<{ progress: number }> = ({ progress }) => {
+  useEffect(() => {
+    // Initialize analytics only once on mount
+    // This is intentional - we don't want to track every progress change
+    if (typeof window !== 'undefined') {
+      window.analytics?.track('ProgressBar Rendered', {
+        initialProgress: progress
+      });
+    }
+  }, []); // Devil will argue: "This is mount-only by design, not a bug"
+
+  return (
+    <div className="progress-bar">
+      <div
+        className="progress-fill"
+        style={{ width: `${progress}%` }}
+      />
+    </div>
+  );
+};
diff --git a/test-pr/lib/roadmap-service.ts b/test-pr/lib/roadmap-service.ts
new file mode 100644
index 0000000..298124e
--- /dev/null
+++ b/test-pr/lib/roadmap-service.ts
@@ -0,0 +1,67 @@
+/**
+ * Roadmap Service - CRUD operations for roadmap management
+ *
+ * INTENTIONAL ISSUES:
+ * - Security: IDOR vulnerability (userId from client body)
+ * - HC: Hard delete with cascade (data loss)
+ * - Strict: Missing error handling, type safety violations
+ */
+
+import { db } from '@/lib/db';
+
+// ❌ Security Issue: userId from client body (IDOR)
+// ❌ Strict Issue: any return type
+export async function getRoadmap(req: any) {
+  const { userId, roadmapId } = req.body; // Client controls userId!
+
+  // ❌ Strict Issue: No try-catch, no error handling
+  const roadmap = await db.roadmap.findUnique({
+    where: { id: roadmapId },
+    include: {
+      learningRecords: true,
+      milestones: true
+    }
+  });
+
+  // ❌ Strict Issue: No validation that roadmap belongs to userId
+  return roadmap;
+}
+
+// ❌ HC Issue: Hard delete with cascade - irreversible data loss
+export async function deleteRoadmap(roadmapId: string) {
+  // No soft delete, no backup, no confirmation
+  // This will cascade delete all learningRecords and milestones
+  const result = await db.roadmap.delete({
+    where: { id: roadmapId }
+  });
+
+  return { success: true };
+}
+
+// ❌ Strict Issue: Inconsistent error handling
+export async function createRoadmap(data: any) {
+  try {
+    const roadmap = await db.roadmap.create({
+      data: {
+        title: data.title,
+        userId: data.userId,
+        // ❌ Strict Issue: No validation of required fields
+      }
+    });
+
+    return roadmap;
+  } catch (error) {
+    // ❌ Strict Issue: Always returns 500, no specific error codes
+    throw new Error('Failed to create roadmap');
+  }
+}
+
+// ❌ Strict Issue: Type assertion instead of proper typing
+export async function updateRoadmap(roadmapId: string, updates: any) {
+  const roadmap = await db.roadmap.update({
+    where: { id: roadmapId },
+    data: updates
+  }) as any; // Type assertion abuse
+
+  return roadmap;
+}
diff --git a/test-pr/utils/cache.ts b/test-pr/utils/cache.ts
new file mode 100644
index 0000000..cdb9bb1
--- /dev/null
+++ b/test-pr/utils/cache.ts
@@ -0,0 +1,116 @@
+/**
+ * Simple In-Memory LRU Cache
+ *
+ * INTENTIONAL ISSUES:
+ * - Academic: Off-by-one error in eviction logic
+ * - Academic: Race condition on concurrent access
+ * - Academic: O(n) complexity on every eviction
+ */
+
+interface CacheEntry<T> {
+  value: T;
+  timestamp: number;
+  accessCount: number;
+}
+
+export class LRUCache<T> {
+  private cache: Map<string, CacheEntry<T>>;
+  private maxSize: number;
+  private ttl: number; // milliseconds
+
+  constructor(maxSize: number = 100, ttl: number = 60000) {
+    this.cache = new Map();
+    this.maxSize = maxSize;
+    this.ttl = ttl;
+  }
+
+  // ❌ Academic Issue 1: Race condition
+  // No locking mechanism - concurrent access can corrupt state
+  get(key: string): T | null {
+    const entry = this.cache.get(key);
+
+    if (!entry) {
+      return null;
+    }
+
+    // ❌ Academic Issue 2: Off-by-one in TTL check
+    // Should be `>=` not `>` - items can be accessed exactly at expiry
+    const isExpired = Date.now() - entry.timestamp > this.ttl;
+
+    if (isExpired) {
+      this.cache.delete(key);
+      return null;
+    }
+
+    // Update access count (race condition here)
+    entry.accessCount++;
+    this.cache.set(key, entry);
+
+    return entry.value;
+  }
+
+  // ❌ Academic Issue 3: O(n) eviction on every set
+  set(key: string, value: T): void {
+    // Check if we need to evict
+    if (this.cache.size >= this.maxSize) {
+      this.evictLRU(); // O(n) operation - scans entire Map
+    }
+
+    const entry: CacheEntry<T> = {
+      value,
+      timestamp: Date.now(),
+      accessCount: 1
+    };
+
+    this.cache.set(key, entry);
+  }
+
+  // ❌ Academic Issue 3: Inefficient eviction
+  // Scans all entries to find LRU - should use a proper data structure
+  private evictLRU(): void {
+    let lruKey: string | null = null;
+    let minAccessCount = Infinity;
+
+    // O(n) scan - gets worse as cache grows
+    for (const [key, entry] of this.cache.entries()) {
+      if (entry.accessCount < minAccessCount) {
+        minAccessCount = entry.accessCount;
+        lruKey = key;
+      }
+    }
+
+    if (lruKey) {
+      this.cache.delete(lruKey);
+    }
+  }
+
+  // ❌ Academic Issue 4: Off-by-one in cleanup
+  // Uses `>` instead of `>=` for size check
+  cleanup(): void {
+    const now = Date.now();
+    const keysToDelete: string[] = [];
+
+    for (const [key, entry] of this.cache.entries()) {
+      // ❌ Should check >= maxSize, not just >
+      if (this.cache.size > this.maxSize || now - entry.timestamp > this.ttl) {
+        keysToDelete.push(key);
+      }
+    }
+
+    keysToDelete.forEach(key => this.cache.delete(key));
+  }
+
+  // Helper to check cache state
+  getStats() {
+    return {
+      size: this.cache.size,
+      maxSize: this.maxSize,
+      // ❌ Academic Issue: This can give misleading stats due to race conditions
+      entries: Array.from(this.cache.entries()).map(([key, entry]) => ({
+        key,
+        accessCount: entry.accessCount,
+        age: Date.now() - entry.timestamp
+      }))
+    };
+  }
+}
